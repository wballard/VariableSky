This is the client library, focused on a socket interface.

    uuid = require('node-uuid')
    EventEmitter = require('events').EventEmitter
    Link = require('./link.litcoffee')
    Blackboard = require('./blackboard.litcoffee')
    packPath = require('./util.litcoffee').packPath
    parsePath = require('./util.litcoffee').parsePath
    inspect = require('./util.litcoffee').inspect
    es = require('event-stream')
    websocket = require('websocket-stream')
    streamula = require('./streamula.litcoffee')
    _ = require('lodash')

Yes. On purpose. Appeases browserify.

    linkcommand = require('./commands/client/link.litcoffee')
    savecommand = require('./commands/server/save.litcoffee')
    removecommand = require('./commands/server/remove.litcoffee')

Two different ways to get a WebSocket depending if we are running in a browser
or in node. Shim it in node, count on the browser otherwise. This little patch
is to make this client work from node-node as well as browser-node via browserify.

    if not WebSocket?
        #not in the browser? shim it
        global.WebSocket = require('ws')

Websocket stream reconnector.

    reconnect = (url, connectionCallback) ->
        sock = null
        allowReconnect = true
        connectionCount = 0
        backoff = 100
        reconnector = null
        tryReconnect = ->
            if allowReconnect
                clearTimeout(reconnector) if reconnector
                sock.removeAllListeners() if sock
                backoff = Math.min(backoff * 2, 30000)
                reconnector = setTimeout ->
                    connect(url)
                , backoff
        connect = (url) ->
            sock = websocket(url)
            sock.connectionCount = connectionCount++
            connectionCallback(sock)
            sock.on 'connect', ->
                backoff = 100
            sock.on 'end', tryReconnect
            sock.on 'error', tryReconnect
        connect(url)
        _.extend sock,
            close: ->
                allowReconnect = false
                sock.end()
            interrupt: ->
                console.log 'erroror'
                sock.emit 'error', 'interrupt'
        sock

The client, used to connect to VariableSky. This is designed to be used from node
as well as the browser via `browserify`.

    class Client extends EventEmitter
      constructor: (url, options) ->
        @options = options or {}
        @trace = false
        @client = uuid.v1()
        @counter = 0
        if window?
          if window?.location?.protocol is 'https:'
           defaultUrl = "wss://#{window.document.location.host}/variablesky"
          else
           defaultUrl = "ws://#{window.document.location.host}/variablesky"
        else
          defaultUrl = "/variablesky"
        url = url or defaultUrl

Use this to peep into the blackboard. I'm not sure this a good idea or that
I'll stick with it, but it lets you see a partial replica of the variables in
the sky here in the client. _It may be better to keep this private_.

        @val = @blackboard = new Blackboard()

Keep track of all the links, a list on purpose as you can have multiple links
from the same client.

        @links = []

And a socket, so we can actually talk to the server.

        @sock = reconnect url, (stream) =>
          console.log 'setting up'

The inbound event processing stream, from the server to this client.
Diffs coming back to your self have already been applied as they were
generated by modifying the local variable.

          inbound = [
            es.parse(),
            streamula.map( (todo) =>
              todo.side = 'client'
              if @trace
                  console.log '\nClient<----', inspect(todo)
              todo
            ),
            streamula.map( (todo) =>
              todo.side = 'client2'
              if @trace
                  console.log '\nClient<----', inspect(todo)
              todo
            ),

This is the actual command processor, which will run commands locally in
the client to update state.

            streamula.commandprocessor(
              map:
                link: linkcommand
                save: savecommand
                remove: removecommand
                message: (todo, context) =>
                  @emit todo.topic, todo.message, todo.__client__
              lookup: (m) -> m.command
              skip: (m) -> m.error
              context: @blackboard
            ),

Links are hierarchial, in that links _deep_ in the tree cause links _high_ in
the tree to change if they are parents.

            es.mapSync( (todo) =>
              for link in @links
                if _.isEqual(link.path, _.first(todo.path, link.path.length))
                  if not todo.__do_not_dispatch__
                    if @trace
                      console.log 'dispatching', todo.path, 'to', link.path
                    link.dataCallback todo.error, @blackboard.valueAt(link.path), todo
              todo
            ),

Per command events, used for callbacks.

            es.mapSync( (todo) =>
              @emit todo.__id__, todo
              todo
            ),
            es.mapSync( (todo) =>
              if @trace
                  console.log '\nClient Done', inspect(todo)
            )
          ]

The outbound event processing stream, from this client to the server.

          @outbound = outbound = es.pipeline(

Default identifiers, which command for callbacks and which client for messages.

            es.mapSync( (todo, callback) =>
              _.extend todo,
                __client__: @client
                __id__: "#{@client}:#{Date.now()}:#{@counter++}"
            ),

Hook up callbacks on the way out. These will be fired off by events on the
inbound path when the server returns the complete message.

            es.mapSync( (todo) =>
              if todo.__done__
                done = todo.__done__
                @once todo.__id__, (message) ->
                  done message.error, message.val, message
                delete todo.__done__
              todo
            ),
            es.map( (todo, callback) =>
              if @trace
                  console.log '\nClient---->', inspect(todo)
              callback(null, todo)
            ),
            es.stringify()
          )

Pipe up the inbound and outbound streams, and provide an outbound reference to
allow sending messages back to the server.

          outbound.pipe(stream)
          _.reduce(inbound, ((l, r) -> l.pipe(r)), stream)
          if stream.connectionCount
            @relink()

Fire hose of tracing.

      traceOn: ->
        @trace = true
        this

A general purpose message channel allowing you to stream messages directly
to a specific client.

      send: (client, topic, message) ->
        @outbound.write
          __to__: client
          topic: topic
          message: message
          command: 'message'

Refresh all links, keeps the data in memory up to date after a reconnect.

      relink: =>
        paths =  _.unique(_.pluck(@links, 'path'))
        for path in paths
          console.log 'relink', path
          @outbound.write
            command: 'link'
            path: parsePath(path)
            __relink__: true
        @emit 'relinked'

Create a new data link to the server.

      link: (path, done) =>
        link = new Link(
          @outbound
          , @blackboard
          , path
          , done
          , => @links = _.reject(@links, link)
        )
        @links.push link
        link

AngularJS support. Use this from in a controller to link values to your scope.
This will automatically update the linked value in the scope, and clean itself
up when your scope is destroyed.

      linkToAngular: (path, $scope, name, defaultValue) =>

Indeed, you need angular JS, but there is an ability to specify it via options
if you hooked angular into a 'namespace' rather than just on `window`.

        angular = @options.angular or window?.angular
        if not angular
          throw errors.NO_ANGULAR()

This is the link from angular to Variable Sky. The idea is to get value changes
from the sky and reflect them in the angular scope, and take changes in the angular
scope and push them to the sky. The *hard part* is dealing with the initial update
which isn't an update at all, and trying to not spam the server with
non-change-changes.

        exitcount = 0
        link = @link(path, (error, value, todo) =>

Default value, or chain it in the case we got nothing. This doesn't trigger
a save back to the sky, it is just a local client default. And if you don't
specify a default, it just stays undefined. JavaScript magic.

This works with a cloned object, making a separate reference in angular land
so that operations and modifications are synchronized via commands rather than
direct access.

          value = @blackboard.valueAt(path)

          if angular.isUndefined(value)
            value = defaultValue
          else
            value = angular.copy(value)

Push into angular scope land. This will trigger binding.

          if exitcount++ < 3
            $scope.$apply ->
              $scope[name] = value
        ).equalIs(angular.equals)

Hook back to angular, looking for UI/angular originated changes and push them
back into the sky to automatically save. This little trick keeps you from needing
to call save on your own.

        unwatch = $scope.$watch name, (newValue, oldValue) =>
          if @trace
            console.log 'SCOPE', name
            console.log 'Was:', inspect(oldValue)
            console.log 'Is:', inspect(newValue)
            console.log 'Same:', newValue is oldValue

Saving. Not as simple as just saving

* All undefined, there is no action
* No difference with the blackboard, there is no action

          if angular.isUndefined(newValue) and angular.isUndefined(oldValue)
            null
          else if angular.equals(newValue, @blackboard.valueAt(path))
            null
          else
            link.saveDiff newValue, oldValue
        , true

Clean up your room! Put your toys away!

        $scope.$on '$destroy', =>
          if @trace
            console.log 'CLOSE', link.path
          unwatch()
          link.close()

All done, return the link

        link

Polite close. My money is you never remember to call this, so the server
has a close connection timeout anyhow.

      close: (done) ->
        @removeAllListeners()
        @sock.close()
        (done or ->)()

      interrupt: (done) ->
        @sock.interrupt()
        (done or ->)()

    module.exports = Client

Export to the browser when used in `browserify`. This makes a global.

    if window?
        browser =
            connect: (url) ->
              new Client(url)
        window.variablesky = window.VariableSky = browser
